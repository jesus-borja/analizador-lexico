Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT
    LEFT_BRACKET
    RIGHT_BRACKET

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     data_type -> TYPE_INTEGER
Rule 3     data_type -> TYPE_STRING
Rule 4     data_type -> TYPE_FLOAT
Rule 5     data_type -> TYPE_DOUBLE
Rule 6     data_type -> TYPE_BOOL
Rule 7     data_type -> TYPE_VOID
Rule 8     data_type -> TYPE_NULL
Rule 9     factor -> LEFT_PAREN expr RIGHT_PAREN
Rule 10    factor -> IDENTIFIER
Rule 11    factor -> INT
Rule 12    factor -> FLOAT
Rule 13    factor -> DOUBLE
Rule 14    factor -> STRING
Rule 15    factor -> BOOL
Rule 16    factor -> NOT expr
Rule 17    factor -> expr COMPARISON expr
Rule 18    factor -> expr LESS_THAN expr
Rule 19    factor -> expr GREATER_THAN expr
Rule 20    factor -> expr LESS_EQUAL expr
Rule 21    factor -> expr GREATER_EQUAL expr
Rule 22    factor -> expr NOT_EQUAL expr
Rule 23    factor -> expr AND expr
Rule 24    factor -> expr OR expr
Rule 25    expr -> expr PLUS factor
Rule 26    expr -> expr MINUS factor
Rule 27    expr -> expr TIMES factor
Rule 28    expr -> expr DIVIDE factor
Rule 29    expr -> expr MODULO factor
Rule 30    expr -> expr POWER factor
Rule 31    expr -> factor
Rule 32    var_decl -> IDENTIFIER COLON data_type ASSIGN_OP expr SEMICOLON
Rule 33    param_list -> param_list COMMA IDENTIFIER COLON data_type
Rule 34    param_list -> IDENTIFIER COLON data_type
Rule 35    param_list -> empty
Rule 36    statement_list -> statement_list statement
Rule 37    statement_list -> empty
Rule 38    statement -> expr SEMICOLON
Rule 39    statement -> if_statement
Rule 40    statement -> while_statement
Rule 41    statement -> for_statement
Rule 42    statement -> return_statement
Rule 43    statement -> var_decl SEMICOLON
Rule 44    statement -> block
Rule 45    block -> LEFT_BRACE statement_list RIGHT_BRACE
Rule 46    if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block
Rule 47    if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block
Rule 48    while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block
Rule 49    for_statement -> FOR IDENTIFIER IN IDENTIFIER block
Rule 50    return_statement -> RETURN expr SEMICOLON
Rule 51    func_decl -> FUNCTION IDENTIFIER LEFT_PAREN param_list RIGHT_PAREN ARROW data_type block
Rule 52    empty -> <empty>

Terminals, with rules where they appear

AND                  : 23
ARROW                : 51
ASSIGN_OP            : 32
BOOL                 : 15
COLON                : 32 33 34
COMMA                : 33
COMPARISON           : 17
DIVIDE               : 28
DOT                  : 
DOUBLE               : 13
ELSE                 : 47
FLOAT                : 12
FOR                  : 49
FUNCTION             : 51
GREATER_EQUAL        : 21
GREATER_THAN         : 19
IDENTIFIER           : 10 32 33 34 49 49 51
IF                   : 46 47
IN                   : 49
INT                  : 11
LEFT_BRACE           : 45
LEFT_BRACKET         : 
LEFT_PAREN           : 9 46 47 48 51
LESS_EQUAL           : 20
LESS_THAN            : 18
MINUS                : 26
MODULO               : 29
NOT                  : 16
NOT_EQUAL            : 22
OR                   : 24
PLUS                 : 25
POWER                : 30
RETURN               : 50
RIGHT_BRACE          : 45
RIGHT_BRACKET        : 
RIGHT_PAREN          : 9 46 47 48 51
SEMICOLON            : 32 38 43 50
STRING               : 14
TIMES                : 27
TYPE_BOOL            : 6
TYPE_DOUBLE          : 5
TYPE_FLOAT           : 4
TYPE_INTEGER         : 2
TYPE_NULL            : 8
TYPE_STRING          : 3
TYPE_VOID            : 7
WHILE                : 48
error                : 

Nonterminals, with rules where they appear

block                : 44 46 47 47 48 49 51
data_type            : 32 33 34 51
empty                : 35 37
expr                 : 9 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 26 27 28 29 30 32 38 46 47 48 50
factor               : 25 26 27 28 29 30 31
for_statement        : 41
func_decl            : 
if_statement         : 39
param_list           : 33 51
program              : 0
return_statement     : 42
statement            : 36
statement_list       : 1 36 45
var_decl             : 43
while_statement      : 40

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (36) statement_list -> . statement_list statement
    (37) statement_list -> . empty
    (52) empty -> .

    IF              reduce using rule 52 (empty -> .)
    WHILE           reduce using rule 52 (empty -> .)
    FOR             reduce using rule 52 (empty -> .)
    RETURN          reduce using rule 52 (empty -> .)
    IDENTIFIER      reduce using rule 52 (empty -> .)
    LEFT_BRACE      reduce using rule 52 (empty -> .)
    LEFT_PAREN      reduce using rule 52 (empty -> .)
    INT             reduce using rule 52 (empty -> .)
    FLOAT           reduce using rule 52 (empty -> .)
    DOUBLE          reduce using rule 52 (empty -> .)
    STRING          reduce using rule 52 (empty -> .)
    BOOL            reduce using rule 52 (empty -> .)
    NOT             reduce using rule 52 (empty -> .)
    $end            reduce using rule 52 (empty -> .)

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (36) statement_list -> statement_list . statement
    (38) statement -> . expr SEMICOLON
    (39) statement -> . if_statement
    (40) statement -> . while_statement
    (41) statement -> . for_statement
    (42) statement -> . return_statement
    (43) statement -> . var_decl SEMICOLON
    (44) statement -> . block
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (46) if_statement -> . IF LEFT_PAREN expr RIGHT_PAREN block
    (47) if_statement -> . IF LEFT_PAREN expr RIGHT_PAREN block ELSE block
    (48) while_statement -> . WHILE LEFT_PAREN expr RIGHT_PAREN block
    (49) for_statement -> . FOR IDENTIFIER IN IDENTIFIER block
    (50) return_statement -> . RETURN expr SEMICOLON
    (32) var_decl -> . IDENTIFIER COLON data_type ASSIGN_OP expr SEMICOLON
    (45) block -> . LEFT_BRACE statement_list RIGHT_BRACE
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    $end            reduce using rule 1 (program -> statement_list .)
    IF              shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IDENTIFIER      shift and go to state 17
    LEFT_BRACE      shift and go to state 19
    LEFT_PAREN      shift and go to state 14
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    statement                      shift and go to state 4
    expr                           shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    return_statement               shift and go to state 9
    var_decl                       shift and go to state 10
    block                          shift and go to state 11
    factor                         shift and go to state 12

state 3

    (37) statement_list -> empty .

    IF              reduce using rule 37 (statement_list -> empty .)
    WHILE           reduce using rule 37 (statement_list -> empty .)
    FOR             reduce using rule 37 (statement_list -> empty .)
    RETURN          reduce using rule 37 (statement_list -> empty .)
    IDENTIFIER      reduce using rule 37 (statement_list -> empty .)
    LEFT_BRACE      reduce using rule 37 (statement_list -> empty .)
    LEFT_PAREN      reduce using rule 37 (statement_list -> empty .)
    INT             reduce using rule 37 (statement_list -> empty .)
    FLOAT           reduce using rule 37 (statement_list -> empty .)
    DOUBLE          reduce using rule 37 (statement_list -> empty .)
    STRING          reduce using rule 37 (statement_list -> empty .)
    BOOL            reduce using rule 37 (statement_list -> empty .)
    NOT             reduce using rule 37 (statement_list -> empty .)
    $end            reduce using rule 37 (statement_list -> empty .)
    RIGHT_BRACE     reduce using rule 37 (statement_list -> empty .)


state 4

    (36) statement_list -> statement_list statement .

    IF              reduce using rule 36 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 36 (statement_list -> statement_list statement .)
    FOR             reduce using rule 36 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 36 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 36 (statement_list -> statement_list statement .)
    LEFT_BRACE      reduce using rule 36 (statement_list -> statement_list statement .)
    LEFT_PAREN      reduce using rule 36 (statement_list -> statement_list statement .)
    INT             reduce using rule 36 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 36 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 36 (statement_list -> statement_list statement .)
    STRING          reduce using rule 36 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 36 (statement_list -> statement_list statement .)
    NOT             reduce using rule 36 (statement_list -> statement_list statement .)
    $end            reduce using rule 36 (statement_list -> statement_list statement .)
    RIGHT_BRACE     reduce using rule 36 (statement_list -> statement_list statement .)


state 5

    (38) statement -> expr . SEMICOLON
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       shift and go to state 26
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40


state 6

    (39) statement -> if_statement .

    IF              reduce using rule 39 (statement -> if_statement .)
    WHILE           reduce using rule 39 (statement -> if_statement .)
    FOR             reduce using rule 39 (statement -> if_statement .)
    RETURN          reduce using rule 39 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 39 (statement -> if_statement .)
    LEFT_BRACE      reduce using rule 39 (statement -> if_statement .)
    LEFT_PAREN      reduce using rule 39 (statement -> if_statement .)
    INT             reduce using rule 39 (statement -> if_statement .)
    FLOAT           reduce using rule 39 (statement -> if_statement .)
    DOUBLE          reduce using rule 39 (statement -> if_statement .)
    STRING          reduce using rule 39 (statement -> if_statement .)
    BOOL            reduce using rule 39 (statement -> if_statement .)
    NOT             reduce using rule 39 (statement -> if_statement .)
    $end            reduce using rule 39 (statement -> if_statement .)
    RIGHT_BRACE     reduce using rule 39 (statement -> if_statement .)


state 7

    (40) statement -> while_statement .

    IF              reduce using rule 40 (statement -> while_statement .)
    WHILE           reduce using rule 40 (statement -> while_statement .)
    FOR             reduce using rule 40 (statement -> while_statement .)
    RETURN          reduce using rule 40 (statement -> while_statement .)
    IDENTIFIER      reduce using rule 40 (statement -> while_statement .)
    LEFT_BRACE      reduce using rule 40 (statement -> while_statement .)
    LEFT_PAREN      reduce using rule 40 (statement -> while_statement .)
    INT             reduce using rule 40 (statement -> while_statement .)
    FLOAT           reduce using rule 40 (statement -> while_statement .)
    DOUBLE          reduce using rule 40 (statement -> while_statement .)
    STRING          reduce using rule 40 (statement -> while_statement .)
    BOOL            reduce using rule 40 (statement -> while_statement .)
    NOT             reduce using rule 40 (statement -> while_statement .)
    $end            reduce using rule 40 (statement -> while_statement .)
    RIGHT_BRACE     reduce using rule 40 (statement -> while_statement .)


state 8

    (41) statement -> for_statement .

    IF              reduce using rule 41 (statement -> for_statement .)
    WHILE           reduce using rule 41 (statement -> for_statement .)
    FOR             reduce using rule 41 (statement -> for_statement .)
    RETURN          reduce using rule 41 (statement -> for_statement .)
    IDENTIFIER      reduce using rule 41 (statement -> for_statement .)
    LEFT_BRACE      reduce using rule 41 (statement -> for_statement .)
    LEFT_PAREN      reduce using rule 41 (statement -> for_statement .)
    INT             reduce using rule 41 (statement -> for_statement .)
    FLOAT           reduce using rule 41 (statement -> for_statement .)
    DOUBLE          reduce using rule 41 (statement -> for_statement .)
    STRING          reduce using rule 41 (statement -> for_statement .)
    BOOL            reduce using rule 41 (statement -> for_statement .)
    NOT             reduce using rule 41 (statement -> for_statement .)
    $end            reduce using rule 41 (statement -> for_statement .)
    RIGHT_BRACE     reduce using rule 41 (statement -> for_statement .)


state 9

    (42) statement -> return_statement .

    IF              reduce using rule 42 (statement -> return_statement .)
    WHILE           reduce using rule 42 (statement -> return_statement .)
    FOR             reduce using rule 42 (statement -> return_statement .)
    RETURN          reduce using rule 42 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 42 (statement -> return_statement .)
    LEFT_BRACE      reduce using rule 42 (statement -> return_statement .)
    LEFT_PAREN      reduce using rule 42 (statement -> return_statement .)
    INT             reduce using rule 42 (statement -> return_statement .)
    FLOAT           reduce using rule 42 (statement -> return_statement .)
    DOUBLE          reduce using rule 42 (statement -> return_statement .)
    STRING          reduce using rule 42 (statement -> return_statement .)
    BOOL            reduce using rule 42 (statement -> return_statement .)
    NOT             reduce using rule 42 (statement -> return_statement .)
    $end            reduce using rule 42 (statement -> return_statement .)
    RIGHT_BRACE     reduce using rule 42 (statement -> return_statement .)


state 10

    (43) statement -> var_decl . SEMICOLON

    SEMICOLON       shift and go to state 41


state 11

    (44) statement -> block .

    IF              reduce using rule 44 (statement -> block .)
    WHILE           reduce using rule 44 (statement -> block .)
    FOR             reduce using rule 44 (statement -> block .)
    RETURN          reduce using rule 44 (statement -> block .)
    IDENTIFIER      reduce using rule 44 (statement -> block .)
    LEFT_BRACE      reduce using rule 44 (statement -> block .)
    LEFT_PAREN      reduce using rule 44 (statement -> block .)
    INT             reduce using rule 44 (statement -> block .)
    FLOAT           reduce using rule 44 (statement -> block .)
    DOUBLE          reduce using rule 44 (statement -> block .)
    STRING          reduce using rule 44 (statement -> block .)
    BOOL            reduce using rule 44 (statement -> block .)
    NOT             reduce using rule 44 (statement -> block .)
    $end            reduce using rule 44 (statement -> block .)
    RIGHT_BRACE     reduce using rule 44 (statement -> block .)


state 12

    (31) expr -> factor .

    SEMICOLON       reduce using rule 31 (expr -> factor .)
    PLUS            reduce using rule 31 (expr -> factor .)
    MINUS           reduce using rule 31 (expr -> factor .)
    TIMES           reduce using rule 31 (expr -> factor .)
    DIVIDE          reduce using rule 31 (expr -> factor .)
    MODULO          reduce using rule 31 (expr -> factor .)
    POWER           reduce using rule 31 (expr -> factor .)
    COMPARISON      reduce using rule 31 (expr -> factor .)
    LESS_THAN       reduce using rule 31 (expr -> factor .)
    GREATER_THAN    reduce using rule 31 (expr -> factor .)
    LESS_EQUAL      reduce using rule 31 (expr -> factor .)
    GREATER_EQUAL   reduce using rule 31 (expr -> factor .)
    NOT_EQUAL       reduce using rule 31 (expr -> factor .)
    AND             reduce using rule 31 (expr -> factor .)
    OR              reduce using rule 31 (expr -> factor .)
    RIGHT_PAREN     reduce using rule 31 (expr -> factor .)


state 13

    (46) if_statement -> IF . LEFT_PAREN expr RIGHT_PAREN block
    (47) if_statement -> IF . LEFT_PAREN expr RIGHT_PAREN block ELSE block

    LEFT_PAREN      shift and go to state 42


state 14

    (9) factor -> LEFT_PAREN . expr RIGHT_PAREN
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 43
    factor                         shift and go to state 12

state 15

    (48) while_statement -> WHILE . LEFT_PAREN expr RIGHT_PAREN block

    LEFT_PAREN      shift and go to state 45


state 16

    (49) for_statement -> FOR . IDENTIFIER IN IDENTIFIER block

    IDENTIFIER      shift and go to state 46


state 17

    (32) var_decl -> IDENTIFIER . COLON data_type ASSIGN_OP expr SEMICOLON
    (10) factor -> IDENTIFIER .

    COLON           shift and go to state 47
    SEMICOLON       reduce using rule 10 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 10 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 10 (factor -> IDENTIFIER .)
    TIMES           reduce using rule 10 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 10 (factor -> IDENTIFIER .)
    MODULO          reduce using rule 10 (factor -> IDENTIFIER .)
    POWER           reduce using rule 10 (factor -> IDENTIFIER .)
    COMPARISON      reduce using rule 10 (factor -> IDENTIFIER .)
    LESS_THAN       reduce using rule 10 (factor -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 10 (factor -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 10 (factor -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 10 (factor -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 10 (factor -> IDENTIFIER .)
    AND             reduce using rule 10 (factor -> IDENTIFIER .)
    OR              reduce using rule 10 (factor -> IDENTIFIER .)


state 18

    (50) return_statement -> RETURN . expr SEMICOLON
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 48
    factor                         shift and go to state 12

state 19

    (45) block -> LEFT_BRACE . statement_list RIGHT_BRACE
    (36) statement_list -> . statement_list statement
    (37) statement_list -> . empty
    (52) empty -> .

    RIGHT_BRACE     reduce using rule 52 (empty -> .)
    IF              reduce using rule 52 (empty -> .)
    WHILE           reduce using rule 52 (empty -> .)
    FOR             reduce using rule 52 (empty -> .)
    RETURN          reduce using rule 52 (empty -> .)
    IDENTIFIER      reduce using rule 52 (empty -> .)
    LEFT_BRACE      reduce using rule 52 (empty -> .)
    LEFT_PAREN      reduce using rule 52 (empty -> .)
    INT             reduce using rule 52 (empty -> .)
    FLOAT           reduce using rule 52 (empty -> .)
    DOUBLE          reduce using rule 52 (empty -> .)
    STRING          reduce using rule 52 (empty -> .)
    BOOL            reduce using rule 52 (empty -> .)
    NOT             reduce using rule 52 (empty -> .)

    statement_list                 shift and go to state 49
    empty                          shift and go to state 3

state 20

    (11) factor -> INT .

    SEMICOLON       reduce using rule 11 (factor -> INT .)
    PLUS            reduce using rule 11 (factor -> INT .)
    MINUS           reduce using rule 11 (factor -> INT .)
    TIMES           reduce using rule 11 (factor -> INT .)
    DIVIDE          reduce using rule 11 (factor -> INT .)
    MODULO          reduce using rule 11 (factor -> INT .)
    POWER           reduce using rule 11 (factor -> INT .)
    COMPARISON      reduce using rule 11 (factor -> INT .)
    LESS_THAN       reduce using rule 11 (factor -> INT .)
    GREATER_THAN    reduce using rule 11 (factor -> INT .)
    LESS_EQUAL      reduce using rule 11 (factor -> INT .)
    GREATER_EQUAL   reduce using rule 11 (factor -> INT .)
    NOT_EQUAL       reduce using rule 11 (factor -> INT .)
    AND             reduce using rule 11 (factor -> INT .)
    OR              reduce using rule 11 (factor -> INT .)
    RIGHT_PAREN     reduce using rule 11 (factor -> INT .)


state 21

    (12) factor -> FLOAT .

    SEMICOLON       reduce using rule 12 (factor -> FLOAT .)
    PLUS            reduce using rule 12 (factor -> FLOAT .)
    MINUS           reduce using rule 12 (factor -> FLOAT .)
    TIMES           reduce using rule 12 (factor -> FLOAT .)
    DIVIDE          reduce using rule 12 (factor -> FLOAT .)
    MODULO          reduce using rule 12 (factor -> FLOAT .)
    POWER           reduce using rule 12 (factor -> FLOAT .)
    COMPARISON      reduce using rule 12 (factor -> FLOAT .)
    LESS_THAN       reduce using rule 12 (factor -> FLOAT .)
    GREATER_THAN    reduce using rule 12 (factor -> FLOAT .)
    LESS_EQUAL      reduce using rule 12 (factor -> FLOAT .)
    GREATER_EQUAL   reduce using rule 12 (factor -> FLOAT .)
    NOT_EQUAL       reduce using rule 12 (factor -> FLOAT .)
    AND             reduce using rule 12 (factor -> FLOAT .)
    OR              reduce using rule 12 (factor -> FLOAT .)
    RIGHT_PAREN     reduce using rule 12 (factor -> FLOAT .)


state 22

    (13) factor -> DOUBLE .

    SEMICOLON       reduce using rule 13 (factor -> DOUBLE .)
    PLUS            reduce using rule 13 (factor -> DOUBLE .)
    MINUS           reduce using rule 13 (factor -> DOUBLE .)
    TIMES           reduce using rule 13 (factor -> DOUBLE .)
    DIVIDE          reduce using rule 13 (factor -> DOUBLE .)
    MODULO          reduce using rule 13 (factor -> DOUBLE .)
    POWER           reduce using rule 13 (factor -> DOUBLE .)
    COMPARISON      reduce using rule 13 (factor -> DOUBLE .)
    LESS_THAN       reduce using rule 13 (factor -> DOUBLE .)
    GREATER_THAN    reduce using rule 13 (factor -> DOUBLE .)
    LESS_EQUAL      reduce using rule 13 (factor -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 13 (factor -> DOUBLE .)
    NOT_EQUAL       reduce using rule 13 (factor -> DOUBLE .)
    AND             reduce using rule 13 (factor -> DOUBLE .)
    OR              reduce using rule 13 (factor -> DOUBLE .)
    RIGHT_PAREN     reduce using rule 13 (factor -> DOUBLE .)


state 23

    (14) factor -> STRING .

    SEMICOLON       reduce using rule 14 (factor -> STRING .)
    PLUS            reduce using rule 14 (factor -> STRING .)
    MINUS           reduce using rule 14 (factor -> STRING .)
    TIMES           reduce using rule 14 (factor -> STRING .)
    DIVIDE          reduce using rule 14 (factor -> STRING .)
    MODULO          reduce using rule 14 (factor -> STRING .)
    POWER           reduce using rule 14 (factor -> STRING .)
    COMPARISON      reduce using rule 14 (factor -> STRING .)
    LESS_THAN       reduce using rule 14 (factor -> STRING .)
    GREATER_THAN    reduce using rule 14 (factor -> STRING .)
    LESS_EQUAL      reduce using rule 14 (factor -> STRING .)
    GREATER_EQUAL   reduce using rule 14 (factor -> STRING .)
    NOT_EQUAL       reduce using rule 14 (factor -> STRING .)
    AND             reduce using rule 14 (factor -> STRING .)
    OR              reduce using rule 14 (factor -> STRING .)
    RIGHT_PAREN     reduce using rule 14 (factor -> STRING .)


state 24

    (15) factor -> BOOL .

    SEMICOLON       reduce using rule 15 (factor -> BOOL .)
    PLUS            reduce using rule 15 (factor -> BOOL .)
    MINUS           reduce using rule 15 (factor -> BOOL .)
    TIMES           reduce using rule 15 (factor -> BOOL .)
    DIVIDE          reduce using rule 15 (factor -> BOOL .)
    MODULO          reduce using rule 15 (factor -> BOOL .)
    POWER           reduce using rule 15 (factor -> BOOL .)
    COMPARISON      reduce using rule 15 (factor -> BOOL .)
    LESS_THAN       reduce using rule 15 (factor -> BOOL .)
    GREATER_THAN    reduce using rule 15 (factor -> BOOL .)
    LESS_EQUAL      reduce using rule 15 (factor -> BOOL .)
    GREATER_EQUAL   reduce using rule 15 (factor -> BOOL .)
    NOT_EQUAL       reduce using rule 15 (factor -> BOOL .)
    AND             reduce using rule 15 (factor -> BOOL .)
    OR              reduce using rule 15 (factor -> BOOL .)
    RIGHT_PAREN     reduce using rule 15 (factor -> BOOL .)


state 25

    (16) factor -> NOT . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 50
    factor                         shift and go to state 12

state 26

    (38) statement -> expr SEMICOLON .

    IF              reduce using rule 38 (statement -> expr SEMICOLON .)
    WHILE           reduce using rule 38 (statement -> expr SEMICOLON .)
    FOR             reduce using rule 38 (statement -> expr SEMICOLON .)
    RETURN          reduce using rule 38 (statement -> expr SEMICOLON .)
    IDENTIFIER      reduce using rule 38 (statement -> expr SEMICOLON .)
    LEFT_BRACE      reduce using rule 38 (statement -> expr SEMICOLON .)
    LEFT_PAREN      reduce using rule 38 (statement -> expr SEMICOLON .)
    INT             reduce using rule 38 (statement -> expr SEMICOLON .)
    FLOAT           reduce using rule 38 (statement -> expr SEMICOLON .)
    DOUBLE          reduce using rule 38 (statement -> expr SEMICOLON .)
    STRING          reduce using rule 38 (statement -> expr SEMICOLON .)
    BOOL            reduce using rule 38 (statement -> expr SEMICOLON .)
    NOT             reduce using rule 38 (statement -> expr SEMICOLON .)
    $end            reduce using rule 38 (statement -> expr SEMICOLON .)
    RIGHT_BRACE     reduce using rule 38 (statement -> expr SEMICOLON .)


state 27

    (25) expr -> expr PLUS . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 51
    factor                         shift and go to state 52

state 28

    (26) expr -> expr MINUS . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 51
    factor                         shift and go to state 53

state 29

    (27) expr -> expr TIMES . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 51
    factor                         shift and go to state 54

state 30

    (28) expr -> expr DIVIDE . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 51
    factor                         shift and go to state 55

state 31

    (29) expr -> expr MODULO . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 51
    factor                         shift and go to state 56

state 32

    (30) expr -> expr POWER . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 51
    factor                         shift and go to state 57

state 33

    (17) factor -> expr COMPARISON . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 58
    factor                         shift and go to state 12

state 34

    (18) factor -> expr LESS_THAN . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 59
    factor                         shift and go to state 12

state 35

    (19) factor -> expr GREATER_THAN . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 60
    factor                         shift and go to state 12

state 36

    (20) factor -> expr LESS_EQUAL . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 61
    factor                         shift and go to state 12

state 37

    (21) factor -> expr GREATER_EQUAL . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 62
    factor                         shift and go to state 12

state 38

    (22) factor -> expr NOT_EQUAL . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 63
    factor                         shift and go to state 12

state 39

    (23) factor -> expr AND . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 64
    factor                         shift and go to state 12

state 40

    (24) factor -> expr OR . expr
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 65
    factor                         shift and go to state 12

state 41

    (43) statement -> var_decl SEMICOLON .

    IF              reduce using rule 43 (statement -> var_decl SEMICOLON .)
    WHILE           reduce using rule 43 (statement -> var_decl SEMICOLON .)
    FOR             reduce using rule 43 (statement -> var_decl SEMICOLON .)
    RETURN          reduce using rule 43 (statement -> var_decl SEMICOLON .)
    IDENTIFIER      reduce using rule 43 (statement -> var_decl SEMICOLON .)
    LEFT_BRACE      reduce using rule 43 (statement -> var_decl SEMICOLON .)
    LEFT_PAREN      reduce using rule 43 (statement -> var_decl SEMICOLON .)
    INT             reduce using rule 43 (statement -> var_decl SEMICOLON .)
    FLOAT           reduce using rule 43 (statement -> var_decl SEMICOLON .)
    DOUBLE          reduce using rule 43 (statement -> var_decl SEMICOLON .)
    STRING          reduce using rule 43 (statement -> var_decl SEMICOLON .)
    BOOL            reduce using rule 43 (statement -> var_decl SEMICOLON .)
    NOT             reduce using rule 43 (statement -> var_decl SEMICOLON .)
    $end            reduce using rule 43 (statement -> var_decl SEMICOLON .)
    RIGHT_BRACE     reduce using rule 43 (statement -> var_decl SEMICOLON .)


state 42

    (46) if_statement -> IF LEFT_PAREN . expr RIGHT_PAREN block
    (47) if_statement -> IF LEFT_PAREN . expr RIGHT_PAREN block ELSE block
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 66
    factor                         shift and go to state 12

state 43

    (9) factor -> LEFT_PAREN expr . RIGHT_PAREN
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    RIGHT_PAREN     shift and go to state 67
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40


state 44

    (10) factor -> IDENTIFIER .

    RIGHT_PAREN     reduce using rule 10 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 10 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 10 (factor -> IDENTIFIER .)
    TIMES           reduce using rule 10 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 10 (factor -> IDENTIFIER .)
    MODULO          reduce using rule 10 (factor -> IDENTIFIER .)
    POWER           reduce using rule 10 (factor -> IDENTIFIER .)
    COMPARISON      reduce using rule 10 (factor -> IDENTIFIER .)
    LESS_THAN       reduce using rule 10 (factor -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 10 (factor -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 10 (factor -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 10 (factor -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 10 (factor -> IDENTIFIER .)
    AND             reduce using rule 10 (factor -> IDENTIFIER .)
    OR              reduce using rule 10 (factor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 10 (factor -> IDENTIFIER .)


state 45

    (48) while_statement -> WHILE LEFT_PAREN . expr RIGHT_PAREN block
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 68
    factor                         shift and go to state 12

state 46

    (49) for_statement -> FOR IDENTIFIER . IN IDENTIFIER block

    IN              shift and go to state 69


state 47

    (32) var_decl -> IDENTIFIER COLON . data_type ASSIGN_OP expr SEMICOLON
    (2) data_type -> . TYPE_INTEGER
    (3) data_type -> . TYPE_STRING
    (4) data_type -> . TYPE_FLOAT
    (5) data_type -> . TYPE_DOUBLE
    (6) data_type -> . TYPE_BOOL
    (7) data_type -> . TYPE_VOID
    (8) data_type -> . TYPE_NULL

    TYPE_INTEGER    shift and go to state 71
    TYPE_STRING     shift and go to state 72
    TYPE_FLOAT      shift and go to state 73
    TYPE_DOUBLE     shift and go to state 74
    TYPE_BOOL       shift and go to state 75
    TYPE_VOID       shift and go to state 76
    TYPE_NULL       shift and go to state 77

    data_type                      shift and go to state 70

state 48

    (50) return_statement -> RETURN expr . SEMICOLON
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       shift and go to state 78
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40


state 49

    (45) block -> LEFT_BRACE statement_list . RIGHT_BRACE
    (36) statement_list -> statement_list . statement
    (38) statement -> . expr SEMICOLON
    (39) statement -> . if_statement
    (40) statement -> . while_statement
    (41) statement -> . for_statement
    (42) statement -> . return_statement
    (43) statement -> . var_decl SEMICOLON
    (44) statement -> . block
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (46) if_statement -> . IF LEFT_PAREN expr RIGHT_PAREN block
    (47) if_statement -> . IF LEFT_PAREN expr RIGHT_PAREN block ELSE block
    (48) while_statement -> . WHILE LEFT_PAREN expr RIGHT_PAREN block
    (49) for_statement -> . FOR IDENTIFIER IN IDENTIFIER block
    (50) return_statement -> . RETURN expr SEMICOLON
    (32) var_decl -> . IDENTIFIER COLON data_type ASSIGN_OP expr SEMICOLON
    (45) block -> . LEFT_BRACE statement_list RIGHT_BRACE
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    RIGHT_BRACE     shift and go to state 79
    IF              shift and go to state 13
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    RETURN          shift and go to state 18
    IDENTIFIER      shift and go to state 17
    LEFT_BRACE      shift and go to state 19
    LEFT_PAREN      shift and go to state 14
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    statement                      shift and go to state 4
    expr                           shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    return_statement               shift and go to state 9
    var_decl                       shift and go to state 10
    block                          shift and go to state 11
    factor                         shift and go to state 12

state 50

    (16) factor -> NOT expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 16 (factor -> NOT expr .)
    PLUS            reduce using rule 16 (factor -> NOT expr .)
    MINUS           reduce using rule 16 (factor -> NOT expr .)
    TIMES           reduce using rule 16 (factor -> NOT expr .)
    DIVIDE          reduce using rule 16 (factor -> NOT expr .)
    MODULO          reduce using rule 16 (factor -> NOT expr .)
    POWER           reduce using rule 16 (factor -> NOT expr .)
    COMPARISON      reduce using rule 16 (factor -> NOT expr .)
    LESS_THAN       reduce using rule 16 (factor -> NOT expr .)
    GREATER_THAN    reduce using rule 16 (factor -> NOT expr .)
    LESS_EQUAL      reduce using rule 16 (factor -> NOT expr .)
    GREATER_EQUAL   reduce using rule 16 (factor -> NOT expr .)
    NOT_EQUAL       reduce using rule 16 (factor -> NOT expr .)
    AND             reduce using rule 16 (factor -> NOT expr .)
    OR              reduce using rule 16 (factor -> NOT expr .)
    RIGHT_PAREN     reduce using rule 16 (factor -> NOT expr .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! MODULO          [ shift and go to state 31 ]
  ! POWER           [ shift and go to state 32 ]
  ! COMPARISON      [ shift and go to state 33 ]
  ! LESS_THAN       [ shift and go to state 34 ]
  ! GREATER_THAN    [ shift and go to state 35 ]
  ! LESS_EQUAL      [ shift and go to state 36 ]
  ! GREATER_EQUAL   [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 51

    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor

    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32


state 52

    (25) expr -> expr PLUS factor .
    (31) expr -> factor .

  ! reduce/reduce conflict for COMPARISON resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for AND resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for OR resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for TIMES resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for MODULO resolved using rule 25 (expr -> expr PLUS factor .)
  ! reduce/reduce conflict for POWER resolved using rule 25 (expr -> expr PLUS factor .)
    SEMICOLON       reduce using rule 25 (expr -> expr PLUS factor .)
    PLUS            reduce using rule 25 (expr -> expr PLUS factor .)
    MINUS           reduce using rule 25 (expr -> expr PLUS factor .)
    TIMES           reduce using rule 25 (expr -> expr PLUS factor .)
    DIVIDE          reduce using rule 25 (expr -> expr PLUS factor .)
    MODULO          reduce using rule 25 (expr -> expr PLUS factor .)
    POWER           reduce using rule 25 (expr -> expr PLUS factor .)
    COMPARISON      reduce using rule 25 (expr -> expr PLUS factor .)
    LESS_THAN       reduce using rule 25 (expr -> expr PLUS factor .)
    GREATER_THAN    reduce using rule 25 (expr -> expr PLUS factor .)
    LESS_EQUAL      reduce using rule 25 (expr -> expr PLUS factor .)
    GREATER_EQUAL   reduce using rule 25 (expr -> expr PLUS factor .)
    NOT_EQUAL       reduce using rule 25 (expr -> expr PLUS factor .)
    AND             reduce using rule 25 (expr -> expr PLUS factor .)
    OR              reduce using rule 25 (expr -> expr PLUS factor .)
    RIGHT_PAREN     reduce using rule 25 (expr -> expr PLUS factor .)

  ! COMPARISON      [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_THAN       [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expr -> factor .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expr -> factor .) ]
  ! AND             [ reduce using rule 31 (expr -> factor .) ]
  ! OR              [ reduce using rule 31 (expr -> factor .) ]
  ! PLUS            [ reduce using rule 31 (expr -> factor .) ]
  ! MINUS           [ reduce using rule 31 (expr -> factor .) ]
  ! TIMES           [ reduce using rule 31 (expr -> factor .) ]
  ! DIVIDE          [ reduce using rule 31 (expr -> factor .) ]
  ! MODULO          [ reduce using rule 31 (expr -> factor .) ]
  ! POWER           [ reduce using rule 31 (expr -> factor .) ]


state 53

    (26) expr -> expr MINUS factor .
    (31) expr -> factor .

  ! reduce/reduce conflict for COMPARISON resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for AND resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for OR resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for TIMES resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for MODULO resolved using rule 26 (expr -> expr MINUS factor .)
  ! reduce/reduce conflict for POWER resolved using rule 26 (expr -> expr MINUS factor .)
    SEMICOLON       reduce using rule 26 (expr -> expr MINUS factor .)
    PLUS            reduce using rule 26 (expr -> expr MINUS factor .)
    MINUS           reduce using rule 26 (expr -> expr MINUS factor .)
    TIMES           reduce using rule 26 (expr -> expr MINUS factor .)
    DIVIDE          reduce using rule 26 (expr -> expr MINUS factor .)
    MODULO          reduce using rule 26 (expr -> expr MINUS factor .)
    POWER           reduce using rule 26 (expr -> expr MINUS factor .)
    COMPARISON      reduce using rule 26 (expr -> expr MINUS factor .)
    LESS_THAN       reduce using rule 26 (expr -> expr MINUS factor .)
    GREATER_THAN    reduce using rule 26 (expr -> expr MINUS factor .)
    LESS_EQUAL      reduce using rule 26 (expr -> expr MINUS factor .)
    GREATER_EQUAL   reduce using rule 26 (expr -> expr MINUS factor .)
    NOT_EQUAL       reduce using rule 26 (expr -> expr MINUS factor .)
    AND             reduce using rule 26 (expr -> expr MINUS factor .)
    OR              reduce using rule 26 (expr -> expr MINUS factor .)
    RIGHT_PAREN     reduce using rule 26 (expr -> expr MINUS factor .)

  ! COMPARISON      [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_THAN       [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expr -> factor .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expr -> factor .) ]
  ! AND             [ reduce using rule 31 (expr -> factor .) ]
  ! OR              [ reduce using rule 31 (expr -> factor .) ]
  ! PLUS            [ reduce using rule 31 (expr -> factor .) ]
  ! MINUS           [ reduce using rule 31 (expr -> factor .) ]
  ! TIMES           [ reduce using rule 31 (expr -> factor .) ]
  ! DIVIDE          [ reduce using rule 31 (expr -> factor .) ]
  ! MODULO          [ reduce using rule 31 (expr -> factor .) ]
  ! POWER           [ reduce using rule 31 (expr -> factor .) ]


state 54

    (27) expr -> expr TIMES factor .
    (31) expr -> factor .

  ! reduce/reduce conflict for COMPARISON resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for AND resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for OR resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for TIMES resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for MODULO resolved using rule 27 (expr -> expr TIMES factor .)
  ! reduce/reduce conflict for POWER resolved using rule 27 (expr -> expr TIMES factor .)
    SEMICOLON       reduce using rule 27 (expr -> expr TIMES factor .)
    PLUS            reduce using rule 27 (expr -> expr TIMES factor .)
    MINUS           reduce using rule 27 (expr -> expr TIMES factor .)
    TIMES           reduce using rule 27 (expr -> expr TIMES factor .)
    DIVIDE          reduce using rule 27 (expr -> expr TIMES factor .)
    MODULO          reduce using rule 27 (expr -> expr TIMES factor .)
    POWER           reduce using rule 27 (expr -> expr TIMES factor .)
    COMPARISON      reduce using rule 27 (expr -> expr TIMES factor .)
    LESS_THAN       reduce using rule 27 (expr -> expr TIMES factor .)
    GREATER_THAN    reduce using rule 27 (expr -> expr TIMES factor .)
    LESS_EQUAL      reduce using rule 27 (expr -> expr TIMES factor .)
    GREATER_EQUAL   reduce using rule 27 (expr -> expr TIMES factor .)
    NOT_EQUAL       reduce using rule 27 (expr -> expr TIMES factor .)
    AND             reduce using rule 27 (expr -> expr TIMES factor .)
    OR              reduce using rule 27 (expr -> expr TIMES factor .)
    RIGHT_PAREN     reduce using rule 27 (expr -> expr TIMES factor .)

  ! COMPARISON      [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_THAN       [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expr -> factor .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expr -> factor .) ]
  ! AND             [ reduce using rule 31 (expr -> factor .) ]
  ! OR              [ reduce using rule 31 (expr -> factor .) ]
  ! PLUS            [ reduce using rule 31 (expr -> factor .) ]
  ! MINUS           [ reduce using rule 31 (expr -> factor .) ]
  ! TIMES           [ reduce using rule 31 (expr -> factor .) ]
  ! DIVIDE          [ reduce using rule 31 (expr -> factor .) ]
  ! MODULO          [ reduce using rule 31 (expr -> factor .) ]
  ! POWER           [ reduce using rule 31 (expr -> factor .) ]


state 55

    (28) expr -> expr DIVIDE factor .
    (31) expr -> factor .

  ! reduce/reduce conflict for COMPARISON resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for AND resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for OR resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for TIMES resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for MODULO resolved using rule 28 (expr -> expr DIVIDE factor .)
  ! reduce/reduce conflict for POWER resolved using rule 28 (expr -> expr DIVIDE factor .)
    SEMICOLON       reduce using rule 28 (expr -> expr DIVIDE factor .)
    PLUS            reduce using rule 28 (expr -> expr DIVIDE factor .)
    MINUS           reduce using rule 28 (expr -> expr DIVIDE factor .)
    TIMES           reduce using rule 28 (expr -> expr DIVIDE factor .)
    DIVIDE          reduce using rule 28 (expr -> expr DIVIDE factor .)
    MODULO          reduce using rule 28 (expr -> expr DIVIDE factor .)
    POWER           reduce using rule 28 (expr -> expr DIVIDE factor .)
    COMPARISON      reduce using rule 28 (expr -> expr DIVIDE factor .)
    LESS_THAN       reduce using rule 28 (expr -> expr DIVIDE factor .)
    GREATER_THAN    reduce using rule 28 (expr -> expr DIVIDE factor .)
    LESS_EQUAL      reduce using rule 28 (expr -> expr DIVIDE factor .)
    GREATER_EQUAL   reduce using rule 28 (expr -> expr DIVIDE factor .)
    NOT_EQUAL       reduce using rule 28 (expr -> expr DIVIDE factor .)
    AND             reduce using rule 28 (expr -> expr DIVIDE factor .)
    OR              reduce using rule 28 (expr -> expr DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 28 (expr -> expr DIVIDE factor .)

  ! COMPARISON      [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_THAN       [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expr -> factor .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expr -> factor .) ]
  ! AND             [ reduce using rule 31 (expr -> factor .) ]
  ! OR              [ reduce using rule 31 (expr -> factor .) ]
  ! PLUS            [ reduce using rule 31 (expr -> factor .) ]
  ! MINUS           [ reduce using rule 31 (expr -> factor .) ]
  ! TIMES           [ reduce using rule 31 (expr -> factor .) ]
  ! DIVIDE          [ reduce using rule 31 (expr -> factor .) ]
  ! MODULO          [ reduce using rule 31 (expr -> factor .) ]
  ! POWER           [ reduce using rule 31 (expr -> factor .) ]


state 56

    (29) expr -> expr MODULO factor .
    (31) expr -> factor .

  ! reduce/reduce conflict for COMPARISON resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for AND resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for OR resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for TIMES resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for MODULO resolved using rule 29 (expr -> expr MODULO factor .)
  ! reduce/reduce conflict for POWER resolved using rule 29 (expr -> expr MODULO factor .)
    SEMICOLON       reduce using rule 29 (expr -> expr MODULO factor .)
    PLUS            reduce using rule 29 (expr -> expr MODULO factor .)
    MINUS           reduce using rule 29 (expr -> expr MODULO factor .)
    TIMES           reduce using rule 29 (expr -> expr MODULO factor .)
    DIVIDE          reduce using rule 29 (expr -> expr MODULO factor .)
    MODULO          reduce using rule 29 (expr -> expr MODULO factor .)
    POWER           reduce using rule 29 (expr -> expr MODULO factor .)
    COMPARISON      reduce using rule 29 (expr -> expr MODULO factor .)
    LESS_THAN       reduce using rule 29 (expr -> expr MODULO factor .)
    GREATER_THAN    reduce using rule 29 (expr -> expr MODULO factor .)
    LESS_EQUAL      reduce using rule 29 (expr -> expr MODULO factor .)
    GREATER_EQUAL   reduce using rule 29 (expr -> expr MODULO factor .)
    NOT_EQUAL       reduce using rule 29 (expr -> expr MODULO factor .)
    AND             reduce using rule 29 (expr -> expr MODULO factor .)
    OR              reduce using rule 29 (expr -> expr MODULO factor .)
    RIGHT_PAREN     reduce using rule 29 (expr -> expr MODULO factor .)

  ! COMPARISON      [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_THAN       [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expr -> factor .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expr -> factor .) ]
  ! AND             [ reduce using rule 31 (expr -> factor .) ]
  ! OR              [ reduce using rule 31 (expr -> factor .) ]
  ! PLUS            [ reduce using rule 31 (expr -> factor .) ]
  ! MINUS           [ reduce using rule 31 (expr -> factor .) ]
  ! TIMES           [ reduce using rule 31 (expr -> factor .) ]
  ! DIVIDE          [ reduce using rule 31 (expr -> factor .) ]
  ! MODULO          [ reduce using rule 31 (expr -> factor .) ]
  ! POWER           [ reduce using rule 31 (expr -> factor .) ]


state 57

    (30) expr -> expr POWER factor .
    (31) expr -> factor .

  ! reduce/reduce conflict for COMPARISON resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for AND resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for OR resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for TIMES resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for MODULO resolved using rule 30 (expr -> expr POWER factor .)
  ! reduce/reduce conflict for POWER resolved using rule 30 (expr -> expr POWER factor .)
    SEMICOLON       reduce using rule 30 (expr -> expr POWER factor .)
    PLUS            reduce using rule 30 (expr -> expr POWER factor .)
    MINUS           reduce using rule 30 (expr -> expr POWER factor .)
    TIMES           reduce using rule 30 (expr -> expr POWER factor .)
    DIVIDE          reduce using rule 30 (expr -> expr POWER factor .)
    MODULO          reduce using rule 30 (expr -> expr POWER factor .)
    POWER           reduce using rule 30 (expr -> expr POWER factor .)
    COMPARISON      reduce using rule 30 (expr -> expr POWER factor .)
    LESS_THAN       reduce using rule 30 (expr -> expr POWER factor .)
    GREATER_THAN    reduce using rule 30 (expr -> expr POWER factor .)
    LESS_EQUAL      reduce using rule 30 (expr -> expr POWER factor .)
    GREATER_EQUAL   reduce using rule 30 (expr -> expr POWER factor .)
    NOT_EQUAL       reduce using rule 30 (expr -> expr POWER factor .)
    AND             reduce using rule 30 (expr -> expr POWER factor .)
    OR              reduce using rule 30 (expr -> expr POWER factor .)
    RIGHT_PAREN     reduce using rule 30 (expr -> expr POWER factor .)

  ! COMPARISON      [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_THAN       [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_THAN    [ reduce using rule 31 (expr -> factor .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expr -> factor .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expr -> factor .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expr -> factor .) ]
  ! AND             [ reduce using rule 31 (expr -> factor .) ]
  ! OR              [ reduce using rule 31 (expr -> factor .) ]
  ! PLUS            [ reduce using rule 31 (expr -> factor .) ]
  ! MINUS           [ reduce using rule 31 (expr -> factor .) ]
  ! TIMES           [ reduce using rule 31 (expr -> factor .) ]
  ! DIVIDE          [ reduce using rule 31 (expr -> factor .) ]
  ! MODULO          [ reduce using rule 31 (expr -> factor .) ]
  ! POWER           [ reduce using rule 31 (expr -> factor .) ]


state 58

    (17) factor -> expr COMPARISON expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 17 (factor -> expr COMPARISON expr .)
    COMPARISON      reduce using rule 17 (factor -> expr COMPARISON expr .)
    LESS_THAN       reduce using rule 17 (factor -> expr COMPARISON expr .)
    GREATER_THAN    reduce using rule 17 (factor -> expr COMPARISON expr .)
    LESS_EQUAL      reduce using rule 17 (factor -> expr COMPARISON expr .)
    GREATER_EQUAL   reduce using rule 17 (factor -> expr COMPARISON expr .)
    NOT_EQUAL       reduce using rule 17 (factor -> expr COMPARISON expr .)
    AND             reduce using rule 17 (factor -> expr COMPARISON expr .)
    OR              reduce using rule 17 (factor -> expr COMPARISON expr .)
    RIGHT_PAREN     reduce using rule 17 (factor -> expr COMPARISON expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32

  ! PLUS            [ reduce using rule 17 (factor -> expr COMPARISON expr .) ]
  ! MINUS           [ reduce using rule 17 (factor -> expr COMPARISON expr .) ]
  ! TIMES           [ reduce using rule 17 (factor -> expr COMPARISON expr .) ]
  ! DIVIDE          [ reduce using rule 17 (factor -> expr COMPARISON expr .) ]
  ! MODULO          [ reduce using rule 17 (factor -> expr COMPARISON expr .) ]
  ! POWER           [ reduce using rule 17 (factor -> expr COMPARISON expr .) ]
  ! COMPARISON      [ shift and go to state 33 ]
  ! LESS_THAN       [ shift and go to state 34 ]
  ! GREATER_THAN    [ shift and go to state 35 ]
  ! LESS_EQUAL      [ shift and go to state 36 ]
  ! GREATER_EQUAL   [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 59

    (18) factor -> expr LESS_THAN expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 18 (factor -> expr LESS_THAN expr .)
    COMPARISON      reduce using rule 18 (factor -> expr LESS_THAN expr .)
    LESS_THAN       reduce using rule 18 (factor -> expr LESS_THAN expr .)
    GREATER_THAN    reduce using rule 18 (factor -> expr LESS_THAN expr .)
    LESS_EQUAL      reduce using rule 18 (factor -> expr LESS_THAN expr .)
    GREATER_EQUAL   reduce using rule 18 (factor -> expr LESS_THAN expr .)
    NOT_EQUAL       reduce using rule 18 (factor -> expr LESS_THAN expr .)
    AND             reduce using rule 18 (factor -> expr LESS_THAN expr .)
    OR              reduce using rule 18 (factor -> expr LESS_THAN expr .)
    RIGHT_PAREN     reduce using rule 18 (factor -> expr LESS_THAN expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32

  ! PLUS            [ reduce using rule 18 (factor -> expr LESS_THAN expr .) ]
  ! MINUS           [ reduce using rule 18 (factor -> expr LESS_THAN expr .) ]
  ! TIMES           [ reduce using rule 18 (factor -> expr LESS_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 18 (factor -> expr LESS_THAN expr .) ]
  ! MODULO          [ reduce using rule 18 (factor -> expr LESS_THAN expr .) ]
  ! POWER           [ reduce using rule 18 (factor -> expr LESS_THAN expr .) ]
  ! COMPARISON      [ shift and go to state 33 ]
  ! LESS_THAN       [ shift and go to state 34 ]
  ! GREATER_THAN    [ shift and go to state 35 ]
  ! LESS_EQUAL      [ shift and go to state 36 ]
  ! GREATER_EQUAL   [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 60

    (19) factor -> expr GREATER_THAN expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    COMPARISON      reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    LESS_THAN       reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    GREATER_THAN    reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    LESS_EQUAL      reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    GREATER_EQUAL   reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    NOT_EQUAL       reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    AND             reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    OR              reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    RIGHT_PAREN     reduce using rule 19 (factor -> expr GREATER_THAN expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32

  ! PLUS            [ reduce using rule 19 (factor -> expr GREATER_THAN expr .) ]
  ! MINUS           [ reduce using rule 19 (factor -> expr GREATER_THAN expr .) ]
  ! TIMES           [ reduce using rule 19 (factor -> expr GREATER_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 19 (factor -> expr GREATER_THAN expr .) ]
  ! MODULO          [ reduce using rule 19 (factor -> expr GREATER_THAN expr .) ]
  ! POWER           [ reduce using rule 19 (factor -> expr GREATER_THAN expr .) ]
  ! COMPARISON      [ shift and go to state 33 ]
  ! LESS_THAN       [ shift and go to state 34 ]
  ! GREATER_THAN    [ shift and go to state 35 ]
  ! LESS_EQUAL      [ shift and go to state 36 ]
  ! GREATER_EQUAL   [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 61

    (20) factor -> expr LESS_EQUAL expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    COMPARISON      reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    LESS_THAN       reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    GREATER_THAN    reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    LESS_EQUAL      reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    NOT_EQUAL       reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    AND             reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    OR              reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    RIGHT_PAREN     reduce using rule 20 (factor -> expr LESS_EQUAL expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32

  ! PLUS            [ reduce using rule 20 (factor -> expr LESS_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 20 (factor -> expr LESS_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 20 (factor -> expr LESS_EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 20 (factor -> expr LESS_EQUAL expr .) ]
  ! MODULO          [ reduce using rule 20 (factor -> expr LESS_EQUAL expr .) ]
  ! POWER           [ reduce using rule 20 (factor -> expr LESS_EQUAL expr .) ]
  ! COMPARISON      [ shift and go to state 33 ]
  ! LESS_THAN       [ shift and go to state 34 ]
  ! GREATER_THAN    [ shift and go to state 35 ]
  ! LESS_EQUAL      [ shift and go to state 36 ]
  ! GREATER_EQUAL   [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 62

    (21) factor -> expr GREATER_EQUAL expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    COMPARISON      reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    LESS_THAN       reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    GREATER_THAN    reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    LESS_EQUAL      reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    NOT_EQUAL       reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    AND             reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    OR              reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    RIGHT_PAREN     reduce using rule 21 (factor -> expr GREATER_EQUAL expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32

  ! PLUS            [ reduce using rule 21 (factor -> expr GREATER_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 21 (factor -> expr GREATER_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 21 (factor -> expr GREATER_EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 21 (factor -> expr GREATER_EQUAL expr .) ]
  ! MODULO          [ reduce using rule 21 (factor -> expr GREATER_EQUAL expr .) ]
  ! POWER           [ reduce using rule 21 (factor -> expr GREATER_EQUAL expr .) ]
  ! COMPARISON      [ shift and go to state 33 ]
  ! LESS_THAN       [ shift and go to state 34 ]
  ! GREATER_THAN    [ shift and go to state 35 ]
  ! LESS_EQUAL      [ shift and go to state 36 ]
  ! GREATER_EQUAL   [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 63

    (22) factor -> expr NOT_EQUAL expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    COMPARISON      reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    LESS_THAN       reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    GREATER_THAN    reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    LESS_EQUAL      reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    AND             reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    OR              reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    RIGHT_PAREN     reduce using rule 22 (factor -> expr NOT_EQUAL expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32

  ! PLUS            [ reduce using rule 22 (factor -> expr NOT_EQUAL expr .) ]
  ! MINUS           [ reduce using rule 22 (factor -> expr NOT_EQUAL expr .) ]
  ! TIMES           [ reduce using rule 22 (factor -> expr NOT_EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 22 (factor -> expr NOT_EQUAL expr .) ]
  ! MODULO          [ reduce using rule 22 (factor -> expr NOT_EQUAL expr .) ]
  ! POWER           [ reduce using rule 22 (factor -> expr NOT_EQUAL expr .) ]
  ! COMPARISON      [ shift and go to state 33 ]
  ! LESS_THAN       [ shift and go to state 34 ]
  ! GREATER_THAN    [ shift and go to state 35 ]
  ! LESS_EQUAL      [ shift and go to state 36 ]
  ! GREATER_EQUAL   [ shift and go to state 37 ]
  ! NOT_EQUAL       [ shift and go to state 38 ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 64

    (23) factor -> expr AND expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 23 (factor -> expr AND expr .)
    AND             reduce using rule 23 (factor -> expr AND expr .)
    OR              reduce using rule 23 (factor -> expr AND expr .)
    RIGHT_PAREN     reduce using rule 23 (factor -> expr AND expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38

  ! PLUS            [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! MODULO          [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! POWER           [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! COMPARISON      [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! LESS_THAN       [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! GREATER_THAN    [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! LESS_EQUAL      [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! NOT_EQUAL       [ reduce using rule 23 (factor -> expr AND expr .) ]
  ! AND             [ shift and go to state 39 ]
  ! OR              [ shift and go to state 40 ]


state 65

    (24) factor -> expr OR expr .
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       reduce using rule 24 (factor -> expr OR expr .)
    OR              reduce using rule 24 (factor -> expr OR expr .)
    RIGHT_PAREN     reduce using rule 24 (factor -> expr OR expr .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39

  ! PLUS            [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! MODULO          [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! POWER           [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! COMPARISON      [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! LESS_THAN       [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! GREATER_THAN    [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! LESS_EQUAL      [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! NOT_EQUAL       [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! AND             [ reduce using rule 24 (factor -> expr OR expr .) ]
  ! OR              [ shift and go to state 40 ]


state 66

    (46) if_statement -> IF LEFT_PAREN expr . RIGHT_PAREN block
    (47) if_statement -> IF LEFT_PAREN expr . RIGHT_PAREN block ELSE block
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    RIGHT_PAREN     shift and go to state 80
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40


state 67

    (9) factor -> LEFT_PAREN expr RIGHT_PAREN .

    SEMICOLON       reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    PLUS            reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    MINUS           reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    TIMES           reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    DIVIDE          reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    MODULO          reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    POWER           reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    COMPARISON      reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    LESS_THAN       reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    GREATER_THAN    reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    NOT_EQUAL       reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    AND             reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    OR              reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 9 (factor -> LEFT_PAREN expr RIGHT_PAREN .)


state 68

    (48) while_statement -> WHILE LEFT_PAREN expr . RIGHT_PAREN block
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    RIGHT_PAREN     shift and go to state 81
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40


state 69

    (49) for_statement -> FOR IDENTIFIER IN . IDENTIFIER block

    IDENTIFIER      shift and go to state 82


state 70

    (32) var_decl -> IDENTIFIER COLON data_type . ASSIGN_OP expr SEMICOLON

    ASSIGN_OP       shift and go to state 83


state 71

    (2) data_type -> TYPE_INTEGER .

    ASSIGN_OP       reduce using rule 2 (data_type -> TYPE_INTEGER .)


state 72

    (3) data_type -> TYPE_STRING .

    ASSIGN_OP       reduce using rule 3 (data_type -> TYPE_STRING .)


state 73

    (4) data_type -> TYPE_FLOAT .

    ASSIGN_OP       reduce using rule 4 (data_type -> TYPE_FLOAT .)


state 74

    (5) data_type -> TYPE_DOUBLE .

    ASSIGN_OP       reduce using rule 5 (data_type -> TYPE_DOUBLE .)


state 75

    (6) data_type -> TYPE_BOOL .

    ASSIGN_OP       reduce using rule 6 (data_type -> TYPE_BOOL .)


state 76

    (7) data_type -> TYPE_VOID .

    ASSIGN_OP       reduce using rule 7 (data_type -> TYPE_VOID .)


state 77

    (8) data_type -> TYPE_NULL .

    ASSIGN_OP       reduce using rule 8 (data_type -> TYPE_NULL .)


state 78

    (50) return_statement -> RETURN expr SEMICOLON .

    IF              reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    LEFT_BRACE      reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    LEFT_PAREN      reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    INT             reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    DOUBLE          reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    BOOL            reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    $end            reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)
    RIGHT_BRACE     reduce using rule 50 (return_statement -> RETURN expr SEMICOLON .)


state 79

    (45) block -> LEFT_BRACE statement_list RIGHT_BRACE .

    IF              reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    WHILE           reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FOR             reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RETURN          reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    INT             reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FLOAT           reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRING          reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    BOOL            reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    NOT             reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    $end            reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)
    ELSE            reduce using rule 45 (block -> LEFT_BRACE statement_list RIGHT_BRACE .)


state 80

    (46) if_statement -> IF LEFT_PAREN expr RIGHT_PAREN . block
    (47) if_statement -> IF LEFT_PAREN expr RIGHT_PAREN . block ELSE block
    (45) block -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    block                          shift and go to state 84

state 81

    (48) while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN . block
    (45) block -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    block                          shift and go to state 85

state 82

    (49) for_statement -> FOR IDENTIFIER IN IDENTIFIER . block
    (45) block -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    block                          shift and go to state 86

state 83

    (32) var_decl -> IDENTIFIER COLON data_type ASSIGN_OP . expr SEMICOLON
    (25) expr -> . expr PLUS factor
    (26) expr -> . expr MINUS factor
    (27) expr -> . expr TIMES factor
    (28) expr -> . expr DIVIDE factor
    (29) expr -> . expr MODULO factor
    (30) expr -> . expr POWER factor
    (31) expr -> . factor
    (9) factor -> . LEFT_PAREN expr RIGHT_PAREN
    (10) factor -> . IDENTIFIER
    (11) factor -> . INT
    (12) factor -> . FLOAT
    (13) factor -> . DOUBLE
    (14) factor -> . STRING
    (15) factor -> . BOOL
    (16) factor -> . NOT expr
    (17) factor -> . expr COMPARISON expr
    (18) factor -> . expr LESS_THAN expr
    (19) factor -> . expr GREATER_THAN expr
    (20) factor -> . expr LESS_EQUAL expr
    (21) factor -> . expr GREATER_EQUAL expr
    (22) factor -> . expr NOT_EQUAL expr
    (23) factor -> . expr AND expr
    (24) factor -> . expr OR expr

    LEFT_PAREN      shift and go to state 14
    IDENTIFIER      shift and go to state 44
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    DOUBLE          shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24
    NOT             shift and go to state 25

    expr                           shift and go to state 87
    factor                         shift and go to state 12

state 84

    (46) if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .
    (47) if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block . ELSE block

    IF              reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    WHILE           reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    FOR             reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    RETURN          reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    IDENTIFIER      reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    LEFT_BRACE      reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    LEFT_PAREN      reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    INT             reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    FLOAT           reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    DOUBLE          reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    STRING          reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    BOOL            reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    NOT             reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    $end            reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 46 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block .)
    ELSE            shift and go to state 88


state 85

    (48) while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .

    IF              reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    WHILE           reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    FOR             reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    RETURN          reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    IDENTIFIER      reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    LEFT_BRACE      reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    LEFT_PAREN      reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    INT             reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    FLOAT           reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    DOUBLE          reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    STRING          reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    BOOL            reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    NOT             reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    $end            reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)
    RIGHT_BRACE     reduce using rule 48 (while_statement -> WHILE LEFT_PAREN expr RIGHT_PAREN block .)


state 86

    (49) for_statement -> FOR IDENTIFIER IN IDENTIFIER block .

    IF              reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    WHILE           reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    FOR             reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    RETURN          reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    IDENTIFIER      reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    LEFT_BRACE      reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    LEFT_PAREN      reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    INT             reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    FLOAT           reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    DOUBLE          reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    STRING          reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    BOOL            reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    NOT             reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    $end            reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)
    RIGHT_BRACE     reduce using rule 49 (for_statement -> FOR IDENTIFIER IN IDENTIFIER block .)


state 87

    (32) var_decl -> IDENTIFIER COLON data_type ASSIGN_OP expr . SEMICOLON
    (25) expr -> expr . PLUS factor
    (26) expr -> expr . MINUS factor
    (27) expr -> expr . TIMES factor
    (28) expr -> expr . DIVIDE factor
    (29) expr -> expr . MODULO factor
    (30) expr -> expr . POWER factor
    (17) factor -> expr . COMPARISON expr
    (18) factor -> expr . LESS_THAN expr
    (19) factor -> expr . GREATER_THAN expr
    (20) factor -> expr . LESS_EQUAL expr
    (21) factor -> expr . GREATER_EQUAL expr
    (22) factor -> expr . NOT_EQUAL expr
    (23) factor -> expr . AND expr
    (24) factor -> expr . OR expr

    SEMICOLON       shift and go to state 89
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    MODULO          shift and go to state 31
    POWER           shift and go to state 32
    COMPARISON      shift and go to state 33
    LESS_THAN       shift and go to state 34
    GREATER_THAN    shift and go to state 35
    LESS_EQUAL      shift and go to state 36
    GREATER_EQUAL   shift and go to state 37
    NOT_EQUAL       shift and go to state 38
    AND             shift and go to state 39
    OR              shift and go to state 40


state 88

    (47) if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE . block
    (45) block -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    block                          shift and go to state 90

state 89

    (32) var_decl -> IDENTIFIER COLON data_type ASSIGN_OP expr SEMICOLON .

    SEMICOLON       reduce using rule 32 (var_decl -> IDENTIFIER COLON data_type ASSIGN_OP expr SEMICOLON .)


state 90

    (47) if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .

    IF              reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    WHILE           reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    FOR             reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    RETURN          reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    IDENTIFIER      reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    LEFT_BRACE      reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    LEFT_PAREN      reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    INT             reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    FLOAT           reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    DOUBLE          reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    STRING          reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    BOOL            reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    NOT             reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    $end            reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)
    RIGHT_BRACE     reduce using rule 47 (if_statement -> IF LEFT_PAREN expr RIGHT_PAREN block ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 52 resolved using rule (expr -> expr PLUS factor)
WARNING: rejected rule (expr -> factor) in state 52
WARNING: reduce/reduce conflict in state 53 resolved using rule (expr -> expr MINUS factor)
WARNING: rejected rule (expr -> factor) in state 53
WARNING: reduce/reduce conflict in state 54 resolved using rule (expr -> expr TIMES factor)
WARNING: rejected rule (expr -> factor) in state 54
WARNING: reduce/reduce conflict in state 55 resolved using rule (expr -> expr DIVIDE factor)
WARNING: rejected rule (expr -> factor) in state 55
WARNING: reduce/reduce conflict in state 56 resolved using rule (expr -> expr MODULO factor)
WARNING: rejected rule (expr -> factor) in state 56
WARNING: reduce/reduce conflict in state 57 resolved using rule (expr -> expr POWER factor)
WARNING: rejected rule (expr -> factor) in state 57
