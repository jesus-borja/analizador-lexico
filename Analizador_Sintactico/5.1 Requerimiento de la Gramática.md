## Introduccion
El lenguaje que se va a analizar es un subconjunto simplificado de un lenguaje de programación que soporta declaraciones de funciones, expresiones aritméticas, y estructuras de control como condicionales y bucles. El propósito del analizador sintáctico es transformar una secuencia de tokens generada por el analizador léxico en una estructura de árbol que representa la estructura gramatical del programa. Este árbol se utiliza posteriormente en las etapas de análisis semántico y generación de código del compilador.

## Símbolos Terminales

Terminales:
- Palabras clave: `FUNCTION`, `ARROW`, `IF`, `ELSE`, `FOR`, `IN`, `WHILE`, `RETURN`
- Operadores:
	- Operadores matematicos:`PLUS`, `MINUS`, `TIMES`, `DIVIDE`, `MODULO`, `POWER`
	- Operadores logicos:`ASSIGN_OP`, `COMPARISON`, `LESS_THAN`, `GREATER_THAN`, `GREATER_EQUAL`, `LESS_EQUAL`, `NOT_EQUAL`, `NOT`, `AND`, `OR`
- Delimitadores: `LEFT_PAREN`, `RIGHT_PAREN`, `LEFT_BRACKET`, `RIGHT_BRACKET`, `LEFT_BRACE`, `RIGHT_BRACE`, `SEMICOLON`, `COMMA`, `DOT`, `COLON`
- Literales: `INT`, `FLOAT`, `DOUBLE`, `STRING`, `BOOL`
- Identificadores: 
	- Nombre de variables:`IDENTIFIER`
	- Tipo de dato:   `TIPYE_INTEGER`, `TYPE_STRING`, `TYPE_FLOAT`, `TYPE_DOUBLE`, `    "TYPE_BOOL",`  `TYPE_VOID`  `TYPE_NULL`

## Símbolos no terminales

**TD (TypeData)**:
- Representa los tipos de datos que existen

**VD (VariableDeclaration):**
- Es una unidad ejecutable dentro del lenguaje que representa una expresión de declaración

**FD (FunctionDeclaration:**)
- Describe la estructura de una declaración de función en el lenguaje. Incluye el nombre de la función, lista de parámetros, tipo de retorno y el cuerpo de la función.

**E (Expression)**
- Representa una combinación de términos y operadores que producen un valor. Las expresiones pueden ser aritméticas, lógicas, de asignación, de comparación, etc.

**F (Factor)**
- Representa los componentes más básicos de una expresión, como identificadores, literales numéricos o literales de cadena. También puede incluir expresiones encerradas entre paréntesis.

**FD (FunctionDeclaration)**
- Describe la estructura de una declaración de función en el lenguaje. Incluye el nombre de la función, lista de parámetros, tipo de retorno y el cuerpo de la función.

**PL (ParameterList)**
- Define la lista de parámetros de una función. Puede estar compuesta por cero o más parámetros. Cada parámetro consiste en un identificador y su tipo de dato.

**SL (StatementList):**
- Representa una lista de sentencias dentro de un bloque de código, como el cuerpo de una función o un bloque. Puede contener una o más sentencias.

**S (Statement):**
Es una unidad ejecutable dentro del lenguaje. Puede ser una expresión, una declaración, una estructura de control de flujo (if, while, for), una sentencia de retorno o un bloque de código.

**B (Block):**
Representa un bloque de código delimitado por llaves `{}`. Puede contener una lista de sentencias.

**IfS (IfStatement):**
Esta producción describe la estructura de una sentencia if en el lenguaje. Puede tener una cláusula else opcional. La sentencia if evalúa una expresión y ejecuta un bloque de código si la expresión es verdadera.

**WS (WhileStatement):**
Esta producción define la estructura de una sentencia while en el lenguaje. La sentencia while ejecuta repetidamente un bloque de código mientras la expresión dada sea verdadera.

**FS (ForStatement):**
Describe la estructura de una sentencia for en el lenguaje. La sentencia for se utiliza para iterar sobre una secuencia de valores, como una lista o un rango de números. Puede tener un formato especial para iteraciones sobre listas, como en el caso de FOR IDENTIFIER IN IDENTIFIER.

**RS (ReturnStatement):**
Esta producción describe la estructura de una sentencia return en el lenguaje. La sentencia return se utiliza para devolver un valor de una función. Puede ser seguida opcionalmente por una expresión que representa el valor a devolver.
## Producciones y Reglas
~~~
TD -> TYPE_INTEGER | TYPE_STRING | TYPE_FLOAT | TYPE_DOUBLE | TYPE_BOOL | TYPE_VOID | TYPE_NULL

F -> LEFT_PAREN E RIGHT_PAREN | IDENTIFIER | INT | FLOAT | DOUBLE | STRING | BOOL | NOT E | E COMPARISON E | E LESS_THAN E | E GREATER_THAN E | E LESS_EQUAL E | E GREATER_EQUAL E | E NOT_EQUAL E | E AND E | E OR E

E -> E PLUS F | E MINUS F | E TIMES F | E DIVIDE F | E MODULO F | E POWER F | F

VD -> IDENTIFIER COLON TD  ASSIGN_OP E

PL -> PL COMMA IDENTIFIER COLON TD | IDENTIFIER COLON TD | ε

SL -> SL S | ε

S -> E SEMICOLON | IfS | WS | FS | RS | VD SEMICOLON | B

B -> LEFT_BRACE SL RIGHT_BRACE

IfS -> IF LEFT_PAREN E RIGHT_PAREN B | IF LEFT_PAREN E RIGHT_PAREN B ELSE B |

WS -> WHILE LEFT_PAREN E RIGHT_PAREN B 

FS -> FOR IDENTIFIER IN IDENTIFIER LEFT_BRACE SL RIGHT_BRACE 

RS -> RETURN E SEMICOLON

FD -> FUNCTION IDENTIFIER LEFT_PAREN PL RIGHT_PAREN ARROW TD LEFT_BRACE SL RIGHT_BRACE
~~~

## Simbolo Inicial

**P (Program):**
- Representa un programa completo en el lenguaje. Un programa está compuesto típicamente por una o más declaraciones de funciones

## Precedencia y Asociatividad

- Para los operadores aritméticos (`PLUS`, `MINUS`, `TIMES`, `DIVIDE`, `MODULO`, `POWER`): La precedencia se organiza de mayor a menor de la siguiente manera: `POWER` tiene la mayor precedencia, seguido de `TIMES`, `DIVIDE`, y `MODULO`, y finalmente `PLUS` y `MINUS`. La asociatividad es izquierda, lo que significa que las operaciones se agrupan de izquierda a derecha.
  
- Para los operadores lógicos (`COMPARISON`, `LESS_THAN`, `GREATER_THAN`, `GREATER_EQUAL`, `LESS_EQUAL`, `NOT_EQUAL`, `NOT`, `AND`, `OR`): La precedencia se organiza de mayor a menor de la siguiente manera: `NOT` tiene la mayor precedencia, seguido de `COMPARISON`, `LESS_THAN`, `GREATER_THAN`, `GREATER_EQUAL`, `LESS_EQUAL`, y `NOT_EQUAL`. Por último, `AND` y `OR` tienen la menor precedencia. Al igual que con los operadores aritméticos, la asociatividad es izquierda.

## Producciones y Reglas

TD -> TYPE_INTEGER | TYPE_STRING | TYPE_FLOAT | TYPE_DOUBLE | TYPE_BOOL | TYPE_VOID | TYPE_NULL
// Define los tipos de datos disponibles en el lenguaje.

F -> LEFT_PAREN E RIGHT_PAREN | IDENTIFIER | INT | FLOAT | DOUBLE | STRING | BOOL | NOT E | E COMPARISON E | E LESS_THAN E | E GREATER_THAN E | E LESS_EQUAL E | E GREATER_EQUAL E | E NOT_EQUAL E | E AND E | E OR E
// Define los factores que pueden aparecer en una expresión. Esto incluye identificadores, literales numéricos y de cadena, así como operaciones lógicas y de comparación.

E -> E PLUS F | E MINUS F | E TIMES F | E DIVIDE F | E MODULO F | E POWER F | F
// Define las expresiones aritméticas y lógicas, con la precedencia adecuada para los operadores.

VD -> IDENTIFIER COLON TD  ASSIGN_OP E
// Define la declaración de una variable, que consiste en un identificador seguido de dos puntos y el tipo de dato, seguido opcionalmente por el operador de asignación y una expresión.

PL -> PL COMMA IDENTIFIER COLON TD | IDENTIFIER COLON TD | ε
// Define la lista de parámetros en la declaración de una función. Puede estar compuesta por cero o más parámetros, cada uno con un identificador y un tipo de dato.

SL -> SL S | ε
// Define una lista de sentencias en un bloque de código. Puede contener una o más sentencias, o estar vacía.

S -> E SEMICOLON | IfS | WS | FS | RS | VD SEMICOLON | B
// Define las diferentes formas que puede tomar una sentencia en el lenguaje, incluyendo expresiones seguidas de un punto y coma, estructuras de control de flujo, declaraciones de variables y bloques de código.

B -> LEFT_BRACE SL RIGHT_BRACE
// Define un bloque de código delimitado por llaves, que puede contener una lista de sentencias.

IfS -> IF LEFT_PAREN E RIGHT_PAREN B | IF LEFT_PAREN E RIGHT_PAREN B ELSE B |
// Define la estructura de una sentencia, que puede incluir una cláusula else opcional.

WS -> WHILE LEFT_PAREN E RIGHT_PAREN B 
// Define la estructura de una sentencia while.

FS -> FOR IDENTIFIER IN IDENTIFIER LEFT_BRACE SL RIGHT_BRACE 
// Define la estructura de una sentencia for, que se utiliza para iterar sobre una secuencia de valores.

RS -> RETURN E SEMICOLON
// Define la estructura de una sentencia return, que se utiliza para devolver un valor de una función.

FD -> FUNCTION IDENTIFIER LEFT_PAREN PL RIGHT_PAREN ARROW TD LEFT_BRACE SL RIGHT_BRACE
// Define la estructura de una declaración de función, incluyendo el nombre de la función, la lista de parámetros, el tipo de retorno y el cuerpo de la función.

P (Program): Representa el programa completo en el lenguaje. 
