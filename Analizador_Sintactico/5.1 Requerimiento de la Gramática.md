## Introduccion
El lenguaje que se va a analizar es un subconjunto simplificado de un lenguaje de programación que soporta declaraciones de funciones, expresiones aritméticas, y estructuras de control como condicionales y bucles. El propósito del analizador sintáctico es transformar una secuencia de tokens generada por el analizador léxico en una estructura de árbol que representa la estructura gramatical del programa. Este árbol se utiliza posteriormente en las etapas de análisis semántico y generación de código del compilador.

## Símbolos Terminales

Terminales:
- Palabras clave: `FUNCTION`, `ARROW`, `IF`, `ELSE`, `FOR`, `IN`, `WHILE`, `RETURN`
- Operadores:
	- Operadores matematicos:`PLUS`, `MINUS`, `TIMES`, `DIVIDE`, `MODULO`, `POWER`
	- Operadores logicos:`ASSIGN_OP`, `COMPARISON`, `LESS_THAN`, `GREATER_THAN`, `GREATER_EQUAL`, `LESS_EQUAL`, `NOT_EQUAL`, `NOT`, `AND`, `OR`
- Delimitadores: `LEFT_PAREN`, `RIGHT_PAREN`, `LEFT_BRACKET`, `RIGHT_BRACKET`, `LEFT_BRACE`, `RIGHT_BRACE`, `SEMICOLON`, `COMMA`, `DOT`, `COLON`
- Literales: `INT`, `FLOAT`, `DOUBLE`, `STRING`, `BOOL`
- Identificadores: 
	- Nombre de variables:`IDENTIFIER`
	- Tipo de dato:   `TIPYE_INTEGER`, `TYPE_STRING`, `TYPE_FLOAT`, `TYPE_DOUBLE`, `    "TYPE_BOOL",`  `TYPE_VOID`  `TYPE_NULL`

## Símbolos no terminales

**TD (TypeData):**
- Representa los tipos de datos que existen

**VD (VariableDeclaration):**
- Es una unidad ejecutable dentro del lenguaje que representa una expresión de declaración

**FD (FunctionDeclaration):**
- Describe la estructura de una declaración de función en el lenguaje. Incluye el nombre de la función, lista de parámetros, tipo de retorno y el cuerpo de la función.

**E (Expression):**
- Representa una combinación de términos y operadores que producen un valor. Las expresiones pueden ser aritméticas, lógicas, de asignación, de comparación, etc.

**F (Factor):**
- Representa los componentes más básicos de una expresión, como identificadores, literales numéricos o literales de cadena. También puede incluir expresiones encerradas entre paréntesis.

**PL (ParameterList):**
- Define la lista de parámetros de una función. Puede estar compuesta por cero o más parámetros. Cada parámetro consiste en un identificador y su tipo de dato.

**SL (StatementList):**
- Representa una lista de sentencias dentro de un bloque de código, como el cuerpo de una función o un bloque. Puede contener una o más sentencias.

**S (Statement):**
Es una unidad ejecutable dentro del lenguaje. Puede ser una expresión, una declaración, una estructura de control de flujo (if, while, for), una sentencia de retorno o un bloque de código.

**B (Block):**
Representa un bloque de código delimitado por llaves `{}`. Puede contener una lista de sentencias.

**IfS (IfStatement):**
Esta producción describe la estructura de una sentencia if en el lenguaje. Puede tener una cláusula else opcional. La sentencia if evalúa una expresión y ejecuta un bloque de código si la expresión es verdadera.

**WS (WhileStatement):**
Esta producción define la estructura de una sentencia while en el lenguaje. La sentencia while ejecuta repetidamente un bloque de código mientras la expresión dada sea verdadera.

**FS (ForStatement):**
Describe la estructura de una sentencia for en el lenguaje. La sentencia for se utiliza para iterar sobre una secuencia de valores, como una lista o un rango de números. Puede tener un formato especial para iteraciones sobre listas, como en el caso de FOR IDENTIFIER IN IDENTIFIER.

**RS (ReturnStatement):**
Esta producción describe la estructura de una sentencia return en el lenguaje. La sentencia return se utiliza para devolver un valor de una función. Puede ser seguida opcionalmente por una expresión que representa el valor a devolver.
## Producciones y Reglas
~~~
TD -> TYPE_INTEGER | TYPE_STRING | TYPE_FLOAT | TYPE_DOUBLE | TYPE_BOOL | TYPE_VOID | TYPE_NULL

F -> LEFT_PAREN E RIGHT_PAREN | IDENTIFIER | INT | FLOAT | DOUBLE | STRING | BOOL | NOT E | E COMPARISON E | E LESS_THAN E | E GREATER_THAN E | E LESS_EQUAL E | E GREATER_EQUAL E | E NOT_EQUAL E | E AND E | E OR E

E -> E PLUS F | E MINUS F | E TIMES F | E DIVIDE F | E MODULO F | E POWER F | F

VD -> IDENTIFIER COLON TD  ASSIGN_OP E

PL -> PL COMMA IDENTIFIER COLON TD | IDENTIFIER COLON TD | ε

SL -> SL S | ε

S -> E SEMICOLON | IfS | WS | FS | RS | VD SEMICOLON | B

B -> LEFT_BRACE SL RIGHT_BRACE

IfS -> IF LEFT_PAREN E RIGHT_PAREN B | IF LEFT_PAREN E RIGHT_PAREN B ELSE B |

WS -> WHILE LEFT_PAREN E RIGHT_PAREN B 

FS -> FOR IDENTIFIER IN IDENTIFIER LEFT_BRACE SL RIGHT_BRACE 

RS -> RETURN E SEMICOLON

FD -> FUNCTION IDENTIFIER LEFT_PAREN PL RIGHT_PAREN ARROW TD LEFT_BRACE SL RIGHT_BRACE
~~~

## Simbolo Inicial

**P (Program):**
- Representa un programa completo en el lenguaje. Un programa está compuesto típicamente por una o más declaraciones de funciones

## Precedencia y Asociatividad

- Para los operadores aritméticos (`PLUS`, `MINUS`, `TIMES`, `DIVIDE`, `MODULO`, `POWER`): La precedencia se organiza de mayor a menor de la siguiente manera: `POWER` tiene la mayor precedencia, seguido de `TIMES`, `DIVIDE`, y `MODULO`, y finalmente `PLUS` y `MINUS`. La asociatividad es izquierda, lo que significa que las operaciones se agrupan de izquierda a derecha.
  
- Para los operadores lógicos (`COMPARISON`, `LESS_THAN`, `GREATER_THAN`, `GREATER_EQUAL`, `LESS_EQUAL`, `NOT_EQUAL`, `NOT`, `AND`, `OR`): La precedencia se organiza de mayor a menor de la siguiente manera: `NOT` tiene la mayor precedencia, seguido de `COMPARISON`, `LESS_THAN`, `GREATER_THAN`, `GREATER_EQUAL`, `LESS_EQUAL`, y `NOT_EQUAL`. Por último, `AND` y `OR` tienen la menor precedencia. Al igual que con los operadores aritméticos, la asociatividad es izquierda.

## Comentarios y Anotaciones
- **SL -> SL S | ε**: Se puede usar para abarcar listas de sentencias dentro de un bloque de código, como también puede contener una o más sentencias.

- **PL -> PL COMMA IDENTIFIER COLON TD | IDENTIFIER COLON TD | ε**: PL nos permite definir los parámetros de nuestra función, pudiendo ser cero parámetros.
